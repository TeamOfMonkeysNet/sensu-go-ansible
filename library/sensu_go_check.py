#!/usr/bin/python

ANSIBLE_METADATA = {
    'metadata_version': '1.1',
    'status': ['preview'],
    'supported_by': 'community'
}

DOCUMENTATION = '''
---
author:
  - "Jared Ledvina (@jaredledvina)"
description:
  - "Create/Delete Sensu Go checks"
module: sensu_go_check
options:
  check_hooks:
    description:
      - "An array of check response types with respective arrays of Sensu hook names."
      - "Sensu hooks are commands run by the Sensu agent in response to the result of the check command execution."
      -
        ? "Hooks are executed, in order of precedence, based on their severity type"
        : "1 to 255, ok, warning, critical, unknown, and finally non-zero."
    type: list
  command:
    description:
      - "The check command to be executed."
    type: str
  cron:
    description:
      - "When the check should be executed, using cron syntax or these predefined schedules."
      - Required if I(interval) is not set.
    type: str
  env_vars:
    description:
      - "An array of environment variables to use with command execution."
    type: list
  handlers:
    description:
      - "An array of Sensu event handlers (names) to use for events created by the check."
    type: list
  high_flap_threshold:
    description:
      - "The flap detection high threshold (% state change) for the check. Sensu uses the same flap detection algorithm as Nagios."
    type: int
  host:
    description:
      - "The host to query, needs to be running the sensu-backend for API access."
    required: true
    type: str
  http_agent:
    default: ansible-httpget
    description:
      - "The user agent to configure when accessing the Sensu Go API."
  interval:
    description:
      - "How often the check is executed, in seconds."
      - Required if I(cron) is not set.
    type: int
  low_flap_threshold:
    description:
      - "The flap detection low threshold (% state change) for the check. Sensu uses the same flap detection algorithm as Nagios."
    type: int
  name:
    description:
      - "A unique string used to identify the check."
      - "Check names cannot contain special characters or spaces (validated with Go regex \\A[\\w\\.\\-]+\\z)."
      - "Each check must have a unique name within its namespace."
    required: true
    type: str
  namespace:
    default: default
    description:
      - "The Sensu RBAC namespace that this check belongs to."
    type: str
  output_metric_format:
    choices:
      - nagios_perfdata
      - graphite_plaintext
      - influxdb_line
      - opentsdb_line
    description:
      - "The metric format generated by the check command."
    type: str
  output_metric_handlers:
    description:
      - "An array of Sensu handlers to use for events created by the check."
      - "Each array item must be a string."
      - "output_metric_handlers should be used in place of the handlers attribute if output_metric_format is configured."
    type: list
  password:
    aliases:
      - url_password
    default: P@ssword!
    description:
      - "Password to use when initially authenticating to the Sensu Go API."
    type: str
  port:
    default: 8080
    description:
      - "The port that the Sensu Go API is listening on."
    type: int
  protocol:
    choices:
      - http
      - https
    default: http
    description:
      - "The protocol to use when accessing the Sensu Go API."
    type: str
  proxy_entity_name:
    description:
      - "The entity name, used to create a proxy entity for an external resource (i.e., a network switch)."
      -
        ? "Must match the regex"
        : "\\A[\\w\\.\\-]+\\z"
    type: str
  proxy_requests:
    description:
      - "Sensu proxy request attributes allow you to assign the check to run for multiple entities according to their entity_attributes."
    type: dict
  publish:
    description:
      - "If check requests are published for the check."
    type: bool
  round_robin:
    description:
      - "When set to true, Sensu executes the check once per interval, cycling through each subscribing agent in turn."
    type: bool
  runtime_assets:
    description:
      - "An array of Sensu assets (names), required at runtime for the execution of the I(command)."
    type: list
  silenced:
    description:
      - "If the event is to be silenced."
    type: bool
  state:
    choices:
      - present
      - absent
    default: present
    description:
      - "Whether we are ensuring the check exists or is removed from Sensu Go."
    type: str
  stdin:
    description:
      - "If the Sensu agent writes JSON serialized Sensu entity and check data to the command process STDIN."
      - "The command must expect the JSON data via STDIN, read it, and close STDIN."
    type: bool
  subscriptions:
    description:
      - "An array of Sensu entity subscriptions that check requests will be sent to."
      - "The array cannot be empty and its items must each be a string."
    type: list
  timeout:
    description:
      - "The check execution duration timeout in seconds (hard stop)."
    type: int
  ttl:
    description:
      - "The time to live (TTL) in seconds until check results are considered stale."
      - "If an agent stops publishing results for the check, and the TTL expires, an event will be created for the agents entity."
      - "The check ttl must be greater than the check interval, and should accommodate time for the check execution and result processing to complete."
    type: int
  use_proxy:
    default: "yes"
    description:
      - "Configures Ansible to use or ignore an http_proxy."
    type: bool
  username:
    aliases:
      - url_username
    default: admin
    description:
      - "Username to use when initially authenticating to the Sensu Go API."
    type: str
  validate_certs:
    default: "yes"
    description:
      - "Whether or not Ansible should validate Sensu Go's certs."
    type: bool
short_description: "Manage Sensu Go checks"
version_added: "2.8"
'''

EXAMPLES = '''
- name: Create a new check
  sensu_go_check:
    state: present
    host: sensu.example.com
    port: 8080
    user: admin
    password: P@ssw0rd!
    namespace: default
    name: check_example
    interval: 60

- name: Delete an existing check
  sensu_go_check:
    state: absent
    host: sensu.example.com
    port: 8080
    user: admin
    password: P@ssw0rd!
    namespace: default
    name: check_example
    interval: 60
'''

RETURN = '''
message:
    description: Humanized description of the changes performed
    type: string
    returned: always
    sample: Updated existing Sensu Go check: check_example
differences:
    description: A dict of the changed keys containing a dict of the  old & new values.
    returned: When check has been modified
    type: dictionary
    sample: |
        "difference": {
          "interval": {
            "new": 120,
            "old": 60
           }
         }
'''

import json
import traceback

from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.urls import fetch_url, url_argument_spec

class SensuGo(AnsibleModule):
    def __init__(self, argument_spec, attributes, **kwargs):
        self.headers = {"Content-Type": "application/json" }
        # List of attributes from the upstream specification
        self.attributes = attributes
        #TODO: Why do I need these?
        self._remote_tmp = "bar"
        self._keep_remote_files = False

        args = dict(
            name=dict(type='str', required=True),
            host=dict(type='str', required=True),
            port=dict(type='int', default=8080),
            protocol=dict(type='str', default='http', choices=['http', 'https']),
            url_username=dict(type='str', default='admin', aliases=['username']),
            url_password=dict(type='str', default='P@ssword!', no_log=True, aliases=['password']),
            namespace=dict(type='str', default='default'),
            force_basic_auth=dict(default=True)
        )
        argument_spec.update(args)
        super(SensuGo, self).__init__(argument_spec=argument_spec, **kwargs)

    def get_base_url(self):
        return '%s://%s:%s' % (
            self.params.get('protocol'),
            self.params.get('host'),
            self.params.get('port')
        )

    def request(self, url, method="GET", data=None):
        if data:
            data = self.jsonify(data)
        try:
            resp, info = fetch_url(
                module=self,
                url=url,
                method=method,
                data=data,
                headers=self.headers
            )
        except:
            self.fail_json(
                msg='Failed request to {0}'.format(url),
                exception=traceback.format_exc()
            )
        #TODO: What error codes should we handle here?
        if info['status'] >= 500 or info['status'] == 401:
            self.fail_json(msg='Request to {0} failed with: {1} {2}'.format(
                url,
                info['status'],
                info['body'].strip())
            )
        response = None
        if resp:
            response = resp.read()
            if response:
                try:
                    response = json.loads(response)
                except:
                    self.fail_json(msg='Failed to parse response as JSON: {0}'.format(
                        response),
                        exception=traceback.format_exc()
                    )
        return response, info

    def auth(self):
        url = '%s/auth' % self.get_base_url()
        response, info = self.request(url)
        self.headers.update(
            {'Authorization': 'Bearer ' + response['access_token']}
        )
        self.params['url_username'] = None
        self.params['username'] = None
        self.params['url_password'] = None
        self.params['password'] = None
        self.params['force_basic_auth'] = False

    def get_checks(self):
        url = '{0}/api/core/v2/namespaces/{1}/checks'.format(
            self.get_base_url(),
            self.params['namespace']
        )
        resp, info = self.request(url)
        return resp, info

    def get_check(self):
        url = '{0}/api/core/v2/namespaces/{1}/checks/{2}'.format(
                self.get_base_url(),
                self.params['namespace'],
                self.params['name'])
        resp, info = self.request(url)
        return resp, info

    def compare_check(self, check):
        differences = {}
        for attribute in self.attributes:
            if self.params[attribute] != None:
                #TODO: Does this recursively verify? Do we need to?
                if self.params[attribute] != check[attribute]:
                    differences.update({ attribute: {
                        'new': self.params[attribute],
                        'old': check[attribute]
                    }})
        return differences

    def create_check_definition(self):
        check = {'metadata': {}}
        # Every check definition must include the following:
        check['metadata']['namespace'] = self.params['namespace']
        check['metadata']['name'] = self.params['name']
        for attribute in self.attributes:
            if self.params[attribute] != None:
                check[attribute] = self.params[attribute]
        return check

    def put_check(self, check):
        url = '{0}/api/core/v2/namespaces/{1}/checks/{2}'.format(
                self.get_base_url(),
                self.params['namespace'],
                self.params['name'])
        resp, info = self.request(url, method='PUT', data=check)
        return resp, info

    def post_check(self, check):
        url = '{0}/api/core/v2/namespaces/{1}/checks'.format(
                self.get_base_url(),
                self.params['namespace'])
        resp, info = self.request(url, method='POST', data=check)
        return resp, info

    def delete_check(self):
        url = '{0}/api/core/v2/namespaces/{1}/checks/{2}'.format(
                self.get_base_url(),
                self.params['namespace'],
                self.params['name'])
        resp, info = self.request(url, method='DELETE')
        return resp, info

def run_module():
    # define available arguments/parameters a user can pass to the module
    module_args = url_argument_spec()
    module_args.update(dict(
        state=dict( type='str', default='present', choices=['present', 'absent']
    )))
    sensu_go_check_spec=dict(
        command=dict(type='str'),
        subscriptions=dict(type='list', elements='str'),
        handlers=dict(type='list', elements='str'),
        interval=dict(type='int'),
        cron=dict(type='str'),
        publish=dict(type='bool'),
        timeout=dict(type='int'),
        ttl=dict(type='int'),
        stdin=dict(type='bool'),
        low_flap_threshold=dict(type='int'),
        high_flap_threshold=dict(type='int'),
        runtime_assets=dict(type='list', elements='str'),
        check_hooks=dict(type='list', elements='str'),
        proxy_entity_name=dict(type='str'),
        proxy_requests=dict(type='dict'),
        silenced=dict(type='bool'),
        env_vars=dict(type='list', elements='str'),
        output_metric_format=dict(type='str',
            choices=[
                'nagios_perfdata',
                'graphite_plaintext',
                'influxdb_line',
                'opentsdb_line'
            ]),
        output_metric_handlers=dict(type='list', elements='str'),
        round_robin=dict(type='bool')
    )
    module_args.update(sensu_go_check_spec)
    required_if = [
        ('state', 'present', ['command', 'subscriptions'])
    ]
    required_one_of = [['interval', 'cron']]
    mutually_exclusive = [['interval', 'cron']]

    result = dict(
        changed=False,
        message='',
    )

    module = SensuGo(
        argument_spec=module_args,
        attributes=sorted(sensu_go_check_spec.keys()),
        supports_check_mode=True,
        required_if=required_if,
        required_one_of=required_one_of,
        mutually_exclusive=mutually_exclusive
    )
    module.auth()
    if module.params['state'] == 'present':
        response, info = module.get_check()
        check_def = module.create_check_definition()
        if info['status'] == 404:
            module.post_check(check_def)
            result['changed'] = True
            result['message'] = 'Create new Sensu Go check: {0}'.format(module.params['name'])
        elif info['status'] == 200:
            difference = module.compare_check(response)
            if difference:
                response, info = module.put_check(check_def)
                result['message'] = 'Updated existing Sensu Go check: {0}'.format(module.params['name'])
                result['difference'] = difference
                result['changed'] = True
            else:
                result['message'] = 'Sensu Go check already exists and doesn\'t need to be updated: {0}'.format(module.params['name'])
    elif module.params['state'] == 'absent':
        response, info = module.get_check()
        if info['status'] == 404:
            result['message'] = 'Sensu Go check does not exist: {0}'.format(module.params['name'])
        elif info['status'] == 200:
            reponse, info = module.delete_check()
            result['message'] = 'Deleted Sensu Go check: {0}'.format(module.params['name'])
    module.exit_json(**result)

def main():
    run_module()

if __name__ == '__main__':
    main()
